{-# LANGUAGE LambdaCase, NoMonomorphismRestriction, OverloadedStrings, ScopedTypeVariables #-}

import Control.Arrow(first, second)
import Control.Applicative hiding (Const)
import Control.Monad
import Control.Monad.State.Strict
import Data.Char
import Data.List(find, foldl', intercalate, nub)
import Data.Maybe
import Data.Monoid
import qualified Data.Text as T
import Debug.Trace
import Safe
import Text.Parsec as P
-- import Text.Parsec.Number as P

traceMsgIt msg x = trace (msg ++ show x) x
trace' = const id
--
-- ALists
--
setAL k v = go
  where go [] = [(k,v)]
        go ((k',v'):kvs) | k == k' = (k,v):kvs
                         | otherwise = (k',v') : go kvs
remAL k = filter ((/= k) . fst)

--
-- Types
--
type TVarId = Int
type FldTyp = String
type PrmId = Int
type VarLvl = Int -- a var can only depend on params at a lower level (i.e. introduced before the var was)

data TypeHead
  = TConst String
  | TVar VarLvl TVarId  -- for unknown types during unification, not generated by user
  | TPrm PrmId  -- for skolem constants to get inside lambdas, not generated by user

data Type
  = TLam (Type -> Type)
  | TApp TypeHead [Type]
  | TNil
  | TCons FldTyp Type Type

-- smart constructors for creating Types
--
tApp t1 t2 = case t1 of
  TLam f -> f t2
  TApp f args -> TApp f (args ++ [t2])
  _ -> error $ "tApp: t1="++show t1++", t2="++show t2++"\nrecord type cannot be a type function"

tVar i v = TApp (TVar i v) []
tPrm i = TApp (TPrm i) []
tConst c = TApp (TConst c) []

arrTp t1 t2 = TApp (TConst "->") [t1, t2]
numTp = tConst "Num"
boolTp = tConst "Bool"
strTp = tConst "Str"

-- get maximum PrmId, used to generate new Prm for a type
--
maxTPrm t = case t of
  TLam tf -> maxTPrm $ tf (tPrm 0)
  TApp (TPrm p) args -> maximum $ p : map maxTPrm args
  TApp _ args -> maximum $ 0 : map maxTPrm args
  TCons _ t1 t2 -> maximum $ map maxTPrm [t1, t2]
  TNil -> 0

-- check if a type var is a pattern (as in higher-order patter unification)
-- and give back list of PrmId to which the var was applied
--
isPattern :: VarLvl -> [Type] -> Maybe [PrmId]
isPattern lvl = chkUnique [] <=< sequence . map okPrm
  where okPrm (TApp (TPrm p) []) | p > lvl = Just p
        okPrm _ = Nothing
        chkUnique known [] = Just (reverse known)
        chkUnique known (x:xs) | x `elem` xs = Nothing
                               | otherwise = chkUnique (x:known) xs

  
-- replace the head of a TApp with a type
--
newHead :: Type -> [Type] -> Type
newHead = foldl' tApp

-- replace a Prm by a type in a type
--
substTPrm :: PrmId -> Type -> Type -> Type
substTPrm targ res = go
  where go t = case t of 
          TLam tf -> TLam $ inLam tf go
          TApp (TPrm p) args | p == targ -> newHead res args 
          TApp t1 args -> TApp t1 (map go args)
          TCons l t rt -> TCons l (go t) (go rt)
          TNil -> TNil
        inLam tf f = \x -> substTPrm prm x (f $ tf $ tPrm prm)
          where prm = 1 + maxTPrm (tf $ tPrm 0) 


-- abstract the given PrmId's from a type
--
abstractOver :: Type -> [PrmId] -> Type
abstractOver = foldr (\p tp -> TLam $ \x -> substTPrm p x tp) 

abstractUnivOver :: Type -> [PrmId] -> Type
abstractUnivOver = foldr (\p tp -> TApp (TConst "forall") [TLam $ \x -> substTPrm p x tp]) 


--
-- Printer for Type
--
appPrec = 2
arrPrec = 1
noPrec = 0
showType i p tp = case tp of
    TNil -> "{}"
    TCons _ _ _ -> "{" ++ intercalate ", " flds ++ rnil "}" where (flds, rnil) = showRType i tp
    TApp (TConst "->") [a, b] -> addParen arrPrec $ showType i arrPrec a ++ " -> " ++ showType i noPrec b 
    TApp (TConst c) args -> showApp c args
    TApp (TVar lvl v) args -> showApp ("a" ++ show v ++ if lvl > 0 then "_" ++ show lvl else "") args
    TApp (TPrm p) args -> showApp ("p" ++ show p) args
    TLam tf -> addParen arrPrec $ "\\ " ++ "a" ++ show i ++ " . " ++ showType (i + 1) noPrec (tf $ tVar 0 i)
  where
    addParen p' | p < p' = id
                | otherwise = ("(" ++) . (++ ")")
    showApp x args = addParen (if null args then 10 else appPrec) . intercalate " " . (x :) . map (showType i appPrec) $ args

showRType i rtp = case rtp of
  TNil -> ([], id)
  TCons lbl tp rtp -> first ((lbl ++ ": " ++ showType i noPrec tp) :) $ showRType i rtp
  TApp (TVar lvl v) _ -> ([], (("| " ++ showType i noPrec rtp) ++))
  _ -> error "Bad record type"

instance Show Type where show = showType 0 noPrec


--
-- Unify types
--
data UnifyState = UnifyState {tvars :: [(TVarId, Type)], genSym :: Int} deriving Show
initUS = UnifyState [] 0
nextSym = do
  us <- get
  let i = genSym us
  put us{genSym = i + 1}
  return i
newTVar lvl' args = do v <- nextSym
                       let lvl = fromMaybe v lvl'
                       return $ TApp (TVar lvl v) args
newTPrm = tPrm <$> nextSym

-- perform occurs check and prune away TPrms which v can't depend on
--
occursCheck lvl v = go
  where go prms t = case t of
          TNil -> return ()
          TCons lbl t' rt -> go prms t' >> go prms rt
          TLam tf -> do pId <- nextSym
                        let p = tPrm pId
                        go (pId:prms) (tf p)
          TApp (TConst c) args -> mapM_ (go prms) args
          TApp (TPrm p) args | p <= lvl -> mapM_ (go prms) args
          TApp (TVar lvl' v') args | v /= v' -> do
            let okPrms (TApp (TPrm p) []) = return $ p <= lvl || p `elem` prms
                okPrms _ = lift Nothing
            newArgs <- filterM okPrms args
            argsPrmIds <- mapM getPrmId args
            if length newArgs /= length args
              then do tvNew <- newTVar (Just lvl') newArgs
                      let tvMod = abstractOver tvNew argsPrmIds
                      assign' v' tvMod
              else return ()
          _ -> lift Nothing


getPrmId (TApp (TPrm p) []) = return p
getPrmId _ = lift Nothing

assign lvl v args t = do
  us <- get
  prms <- mapM getPrmId args `mplus` error ("non-pattern problem: " ++ show (TApp (TVar lvl v) args) ++ " =?= " ++ show t)
  occursCheck lvl v prms t
  assign' v $ abstractOver t prms
assign' v t = modify $ \us -> us{tvars = setAL v t (tvars us)}

instantiate :: Type -> StateT UnifyState Maybe Type
instantiate t = do
  us <- get
  let go t = case t of
        TApp (TVar lvl v) args | Just t' <- lookup v (tvars us) -> go $ newHead t' args
        _ -> t
  return $ go t

--
-- unify t1 t2 assumes that the unification problem arose from trying to apply a function of type (t1 -> t) to an argument of type t2.
-- so the order of the arguments makes a difference.
--
unify :: Type -> Type -> StateT UnifyState Maybe ()
unify t1 t2 = do
  t1' <- instantiate t1
  t2' <- instantiate t2
  us <- get
  case trace' ("t1': "++show t1'++", t2': "++show t2'++"\nus="++show us) (t1', t2') of
    (TNil, TNil) -> return ()
    (TCons _ _ _, TCons _ _ _) -> allLblsInRecord t1' t2' >> allLblsInRecord t2' t1'
    (TLam tf1, TLam tf2) -> do
      i <- nextSym 
      let p = tPrm i
      unify (tf1 p) (tf2 p)

    (TApp (TConst "exists") [TLam tf], t') -> do
      newP <- newTPrm 
      unify (tf newP) t'
    (t', TApp (TConst "forall") [TLam tf]) -> do
      newP <- newTPrm 
      unify t' (tf newP)
    (TApp (TConst "forall") [TLam tf], t') -> do
      newV <- newTVar Nothing []
      unify (tf newV) t'
    (t', TApp (TConst "exists") [TLam tf]) -> do
      newV <- newTVar Nothing []
      unify t' (tf newV)

    (TApp (TConst "->") [s1, t1], TApp (TConst "->") [s2, t2]) -> do
      unify s2 s1  -- note the switch in polarity
      unify t1 t2

    (TApp (TConst c1) args1, TApp (TConst c2) args2) | c1 == c2 -> zipWithM_ unify args1 args2
    (TApp (TPrm p1) args1, TApp (TPrm p2) args2) | p1 == p2 -> zipWithM_ unify args1 args2
    
    (TApp (TVar lvl1 v1) args1, TApp (TVar lvl2 v2) args2)
      | lvl1 < lvl2 -> assign lvl1 v1 args1 t2'
      | otherwise -> assign lvl2 v2 args2 t1'
    (TApp (TVar lvl v) args, t) -> assign lvl v args t
    (t, TApp (TVar lvl v) args) -> assign lvl v args t
    _ -> lift Nothing

allLblsInRecord rt1 rt2 = do
  t1 <- instantiate rt1
  case t1 of
    TNil -> return ()
    TCons lbl tp rt -> inRecord lbl tp rt2 >> allLblsInRecord rt rt2
    _ -> return () -- this is loose, only Var case is ok, but other malformed constructions should be caught elsewhere.

inRecord lbl tp = go
  where go rt = do
          rt' <- instantiate rt
          case rt' of
            TCons l t rtNext | l == lbl -> unify t tp `mplus` go rtNext
                             | otherwise  -> go rtNext
            TApp (TVar lvl v) args | Just prmIds <- isPattern lvl args -> do
              newV <- newTVar (Just lvl) $ map tPrm prmIds
              assign lvl v args $ TCons lbl tp newV
            _ -> lift Nothing
            

uniTest x y = do
  t1 <- parseType x
  t2 <- parseType y
  return . fmap snd $ runStateT (unify t1 t2) initUS


--
-- Terms
--
type VarId = String
data Term
  = Lam VarId Term
  | Var VarId
  | App Term Term
  | RNil
  | RCons FldTyp Term Term
  | Proj Term FldTyp
  | Case Term [(Pat, Term)]
  | Const String
  | Num Double
  | Str String
  | Bln Bool
  deriving (Eq, Show)
data Pat
  = PVar VarId
  | PConst String
  | PApp Pat Pat
  deriving (Eq, Show)

showTerm p e = case e of
    RNil -> "{}"
    RCons _ _ _ -> "{" ++ intercalate ", " (showRTerm e) ++ "}"
    Proj e lbl -> showTerm 1 e ++ " # " ++ lbl
    App e1 e2 -> addParen 1 $ showTerm 1 e1 ++ " " ++ showTerm 2 e2
    Const c -> c
    Var v -> v
    Lam x e -> addParen 0 $ "\\ " ++ x ++ " -> " ++ showTerm 0 e
    Case e cases -> addParen 0 $ "case " ++ showTerm 0 e ++ " of " ++ intercalate " | " (map showCase cases)
    Num n -> show n
    Str s -> show s
    Bln b -> show b
  where
    addParen p' | p <= p' = id
                | otherwise = ("(" ++) . (++ ")")
showRTerm RNil = []
showRTerm (RCons lbl e (Var v)) = [lbl ++ " = " ++ showTerm noPrec e ++ " | " ++ v]
showRTerm (RCons lbl e es) = (lbl ++ " = " ++ showTerm noPrec e) : showRTerm es
showCase (p, e) = showPat noPrec p ++ " -> " ++ showTerm noPrec e
showPat _ (PVar x) = x
showPat _ (PConst c) = c
showPat p (PApp p1 p2) = addParen appPrec $ showPat p p1 ++ " " ++ showPat appPrec p2
  where addParen p' | p < p' = id
                    | otherwise = ("(" ++) . (++ ")")

patVars (PVar pv) = [pv]
patVars (PConst _) = []
patVars (PApp p1 p2) = patVars p1 ++ patVars p2

match :: Term -> (Pat, Term) -> Maybe Term
match e (p, e') = fmap ($ e') $ go p e
  where go (PVar x) e = Just (subst x e)
        go (PConst c) (Const c') | c == c' = Just id
        go (PApp p1 p2) (App e1 e2) = (.) <$> go p1 e1 <*> go p2 e2
        go _ _ = Nothing

-- this is only safe when val is a closed term (i.e. has no unbound vars in it).
subst :: VarId -> Term -> Term -> Term
subst var val = go [(var, val)]
  where go env (Var v) | v == var = fromMaybe (Var v) $ lookup v env
        go env (Lam x e) = go ((x, Var x) : env) e
        go env (App e1 e2) = App (go env e1) (go env e2)
        go env (RCons lbl e es) = RCons lbl (go env e) (go env es)
        go env (Case e cases) = Case (go env e) (map (goCase env) cases)
        go _ e = e
        goCase env (pat, e) = (pat, go (map (\v -> (v, Var v)) (patVars pat) ++ env) e)

eval :: Term -> Term
eval (App e1 e2) = case eval e1 of
  Lam x e -> eval $ subst x e2 e
  e -> App e e2
eval (Case e cases) =
  maybe (error "case pattern match failure") eval . getFirst . mconcat $
  map (First . match (eval e)) cases
eval (Proj e lbl) = eval $ getLabel lbl (eval e)
eval e = e

getLabel lbl RNil = error $ "missing label "++show lbl
getLabel lbl (RCons l e es) | lbl == l = e
                            | otherwise = getLabel lbl es
getLabel lbl e = error $ "getLabel: " ++ showTerm 0 e


reservedWords = ["case", "of", "True", "False", "data"]


--
-- Parser for Type
--
data ParseState = ParseState { tbvars :: [(String, Type)]
                             , bvars :: [String]
                             , genSymPS :: Int
                             , types :: [(String, Type)]
                             , constructors :: [(String, Type)]
                             , definitions :: [(String, Term)]
                             }
                  deriving Show
initPS = ParseState [] [] 0 [] [] []

bracketParser open close = between (myString open) (myString close) . lexer
identifierParser = lexer $ (:) <$> letter <*> P.many (alphaNum P.<|> satisfy (`elem` "_'-"))
lexer = (<* spaces)
mySpace = lexer space
myString = lexer . string


typeParser' = (choice $ 
              [ myString "Num" *> pure numTp
              , myString "Bool" *> pure boolTp
              , myString "Str" *> pure strTp
              , TApp (TConst "forall") . (:[]) <$> (myString "forall" *> tlamParser)
              , TApp (TConst "exists") . (:[]) <$> (myString "exists" *> tlamParser)
              , tlamParser 
              , bracketParser "{" "}" rtypParser
              , bracketParser "(" ")" arrTpParser
              , tvarParser
              ]
              ) <?> "type'"
tappParser = chainl1 (typeParser') (pure tApp)
arrTpParser = chainr1 tappParser (myString "->" *> pure arrTp)
typeParser = arrTpParser

tlamParser = do x <- myString "\\" *> (identifierParser <* myString ".")
                ps <- getState
                let i = genSymPS ps
                    absPrm v = TLam $ \bv -> substTPrm i bv v 
                putState ps{ tbvars = (x, tPrm i) : tbvars ps, genSymPS = 1 + i}
                absPrm <$> arrTpParser
                
tvarParser = do v <- identifierParser
                ps <- getState
                let bvs = tbvars ps
--                    i = genSymPS ps
--                    newVar = tVar 0 i
                    res = getFirst . mconcat $ map First [lookup v bvs, fmap snd . find ((== v) .fst) $ types ps]
                maybe (parserFail $ "unbound type: " ++ v) return $ res

rtypParser = mkRowTp <$> sepBy tfldParser (myString ",") <*> option TNil (myString "|" *> tappParser)
  where mkRowTp tps rnil = foldr (\(lbl,tp) -> TCons lbl tp) rnil tps
tfldParser = (,) <$> identifierParser <*> (myString "::" *> arrTpParser) <?> "record field"

parseType = runParser (spaces *> arrTpParser <* eof) initPS ""


patId = (\v -> if isAsciiUpper (headDef ' ' v) then PConst v else PVar v) <$> identifierParser
patParser' = (choice $
              [ bracketParser "(" ")" patParser
              , patId
              ]
             ) <?> "pattern"
patParser = do p <- chainl1 patParser' (pure PApp)
               let vs = patVars p
               if nub vs == vs then return p else parserFail "variable occurs more than once in a pattern"

-- I did this out of laziness because I couldn't get parsec3-numbers to work with parsec3.
numParser = do str <- (\f a b c -> f ++ a ++ b ++ c) <$> option "" (string "-") <*> P.many digit <*> P.option "" (string ".") <*> P.many digit
               maybe (parserFail "bad number") pure $ (readMay str :: Maybe Double)

strParser = bracketParser "\"" "\"" $ P.many $ (string "\\" *> anyChar) P.<|> anyChar

funParser :: [VarId] -> Parsec String [VarId] Term
funParser (newVs :: [VarId]) = do
  vs :: [VarId] <- getState
  putState (newVs ++ vs)
  myString "->"
  e <- termParser
  putState vs
  return e
caseParser = do
  p <- patParser
  e <- funParser (patVars p :: [VarId])
  return (p, e)
lamParser = do
  myString "\\"
  v <- identifierParser
  e <- funParser [v]
  return $ Lam v e
varParser :: Parsec String [VarId] Term
varParser = do
  x <- identifierParser
  vs <- getState
  if x `elem` reservedWords then parserZero  else return $ if x `elem` vs then Var x else Const x
termParser' = (choice $
               [ Num <$> numParser
               , Str <$> strParser
               , recordParser
               , bracketParser "(" ")" termParser
               , lamParser
               , try varParser
               , Case <$> (myString "case" *> termParser) <*> (myString "of" *> sepBy caseParser (myString "|"))
               , Bln <$> (myString "True" *> pure True P.<|> myString "False" *> pure False)
               ]
              ) <?> "Term"
termParser = chainl1 projParser (pure App)
projParser = foldl' Proj <$> termParser' <*> P.many (myString "#" *> identifierParser)

recordParser = bracketParser "{" "}" $ mkRow <$> sepBy fldParser (myString ",") <*> option RNil (myString "|" *> termParser)
  where mkRow ts rnil = foldr (\(lbl,t) -> RCons lbl t) rnil ts
fldParser = (,) <$> identifierParser <*> (myString "=" *> termParser) 

mkVarPrm x = do
  st <- getState
  let i = genSymPS st
  putState st{genSymPS = i + 1}
  return (x, i)

parseData = do
  myString "data"
  name <- identifierParser
  tpids <- mapM mkVarPrm =<< P.many identifierParser
  let tpids' = map snd tpids
      tprms = map (second tPrm) tpids
      tprms' = map snd tprms
      tp = abstractOver (TApp (TConst name) tprms') tpids'
  myString "="
  st <- getState
  let tbvs = tbvars st
  putState st{ tbvars = tprms ++ tbvs
             , types = (name, tp) : types st
             }
  tcons <- sepBy1 ((,) <$> identifierParser <*> fmap (foldr arrTp (TApp (TConst name) tprms')) (P.many typeParser')) (myString "|")
  modifyState (\st -> st{tbvars = tbvs})
  let tcons' = map (second $ \t -> abstractUnivOver t tpids') tcons
  modifyState (\st -> st{constructors = tcons' ++ constructors st})
  stateUser <$> getParserState

